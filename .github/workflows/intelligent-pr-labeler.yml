name: üè∑Ô∏è Intelligent PR Labeler

on:
  pull_request:
    types: [opened, edited, synchronize]
  pull_request_review:
    types: [submitted]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  ai-labeler:
    name: AI-Powered Labeling
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Analyze PR and Apply Labels
        uses: actions/github-script@v8
        with:
          script: |
            const pr = context.payload.pull_request;
            if (!pr) return;

            // Get PR files
            const files = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number
            });

            // Get PR diff stats
            const diffStats = {
              additions: pr.additions,
              deletions: pr.deletions,
              changed_files: pr.changed_files
            };

            const labels = new Set();

            // Size-based labels
            const totalChanges = diffStats.additions + diffStats.deletions;
            if (totalChanges < 10) labels.add('size/XS');
            else if (totalChanges < 50) labels.add('size/S');
            else if (totalChanges < 200) labels.add('size/M');
            else if (totalChanges < 500) labels.add('size/L');
            else labels.add('size/XL');

            // Type-based labels from title and description
            const title = pr.title.toLowerCase();
            const body = (pr.body || '').toLowerCase();
            const text = title + ' ' + body;

            if (text.includes('fix') || text.includes('bug')) labels.add('type/bugfix');
            if (text.includes('feat') || text.includes('feature')) labels.add('type/feature');
            if (text.includes('chore') || text.includes('maintenance')) labels.add('type/chore');
            if (text.includes('docs') || text.includes('documentation')) labels.add('type/docs');
            if (text.includes('test') || text.includes('testing')) labels.add('type/test');
            if (text.includes('refactor') || text.includes('cleanup')) labels.add('type/refactor');
            if (text.includes('perf') || text.includes('performance')) labels.add('type/performance');
            if (text.includes('security') || text.includes('vulnerability')) labels.add('type/security');

            // Technology-based labels from files
            const fileExtensions = files.data.map(f => {
              const ext = f.filename.split('.').pop();
              return ext;
            });

            const filePaths = files.data.map(f => f.filename);

            // Frontend/Backend classification
            if (filePaths.some(f => f.includes('src/') || f.includes('components/') || f.includes('.tsx') || f.includes('.jsx'))) {
              labels.add('area/frontend');
            }
            if (filePaths.some(f => f.includes('server/') || f.includes('api/') || f.includes('backend/'))) {
              labels.add('area/backend');
            }
            if (filePaths.some(f => f.includes('.github/') || f.includes('ci') || f.includes('workflow'))) {
              labels.add('area/ci-cd');
            }
            if (filePaths.some(f => f.includes('test') || f.includes('spec') || f.includes('__tests__'))) {
              labels.add('area/testing');
            }
            if (filePaths.some(f => f.includes('docs/') || f.includes('README') || f.includes('.md'))) {
              labels.add('area/documentation');
            }

            // Platform-specific labels
            if (filePaths.some(f => f.includes('ios/') || f.includes('.ios.'))) {
              labels.add('platform/ios');
            }
            if (filePaths.some(f => f.includes('android/') || f.includes('.android.'))) {
              labels.add('platform/android');
            }

            // Dependency-related labels
            if (filePaths.some(f => f.includes('package.json') || f.includes('yarn.lock') || f.includes('package-lock.json'))) {
              labels.add('dependencies');
            }

            // Priority assessment
            if (text.includes('critical') || text.includes('urgent') || text.includes('hotfix')) {
              labels.add('priority/high');
            } else if (text.includes('important') || text.includes('security')) {
              labels.add('priority/medium');
            } else {
              labels.add('priority/low');
            }

            // Complexity assessment
            if (totalChanges > 500 || diffStats.changed_files > 20) {
              labels.add('complexity/high');
            } else if (totalChanges > 100 || diffStats.changed_files > 5) {
              labels.add('complexity/medium');
            } else {
              labels.add('complexity/low');
            }

            // Special cases
            if (pr.user.login === 'dependabot[bot]') {
              labels.add('dependencies');
              labels.add('automated');
            }

            if (pr.draft) {
              labels.add('status/draft');
            } else {
              labels.add('status/ready-for-review');
            }

            // Apply labels
            const labelsArray = Array.from(labels);
            if (labelsArray.length > 0) {
              await github.rest.issues.setLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels: labelsArray
              });

              console.log(`Applied labels: ${labelsArray.join(', ')}`);
            }

            // Create analysis comment
            const analysisComment = `## ü§ñ AI PR Analysis

**Size:** ${totalChanges} changes across ${diffStats.changed_files} files
**Type:** ${Array.from(labels).filter(l => l.startsWith('type/')).join(', ') || 'Unknown'}
**Areas:** ${Array.from(labels).filter(l => l.startsWith('area/')).join(', ') || 'General'}
**Priority:** ${Array.from(labels).filter(l => l.startsWith('priority/')).join(', ')}
**Complexity:** ${Array.from(labels).filter(l => l.startsWith('complexity/')).join(', ')}

**Files Changed:**
${files.data.slice(0, 10).map(f => \`- \\\`${f.filename}\\\` (+${f.additions}/-${f.deletions})\`).join('\\n')}
${files.data.length > 10 ? \`\\n... and ${files.data.length - 10} more files\` : ''}

**Automated Labels Applied:** ${labelsArray.join(', ')}

*This analysis was generated by AI PR Orchestrator*`;

            // Check if analysis comment already exists
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number
            });

            const existingComment = comments.data.find(c => 
              c.body.includes('ü§ñ AI PR Analysis')
            );

            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: analysisComment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body: analysisComment
              });
            }

  create-labels:
    name: Ensure Labels Exist
    runs-on: ubuntu-latest
    steps:
      - name: Create Required Labels
        uses: actions/github-script@v8
        with:
          script: |
            const labels = [
              // Size labels
              { name: 'size/XS', color: '00ff00', description: 'Extra small PR (< 10 changes)' },
              { name: 'size/S', color: '7cfc00', description: 'Small PR (< 50 changes)' },
              { name: 'size/M', color: 'ffff00', description: 'Medium PR (< 200 changes)' },
              { name: 'size/L', color: 'ffa500', description: 'Large PR (< 500 changes)' },
              { name: 'size/XL', color: 'ff0000', description: 'Extra large PR (500+ changes)' },
              
              // Type labels
              { name: 'type/bugfix', color: 'ff0000', description: 'Bug fix' },
              { name: 'type/feature', color: '00ff00', description: 'New feature' },
              { name: 'type/chore', color: '808080', description: 'Maintenance task' },
              { name: 'type/docs', color: '0000ff', description: 'Documentation' },
              { name: 'type/test', color: 'ff00ff', description: 'Testing' },
              { name: 'type/refactor', color: '00ffff', description: 'Code refactoring' },
              { name: 'type/performance', color: 'ffff00', description: 'Performance improvement' },
              { name: 'type/security', color: 'ff4500', description: 'Security-related' },
              
              // Area labels
              { name: 'area/frontend', color: '1e90ff', description: 'Frontend changes' },
              { name: 'area/backend', color: '32cd32', description: 'Backend changes' },
              { name: 'area/ci-cd', color: '9932cc', description: 'CI/CD changes' },
              { name: 'area/testing', color: 'ff1493', description: 'Testing changes' },
              { name: 'area/documentation', color: '4169e1', description: 'Documentation changes' },
              
              // Platform labels
              { name: 'platform/ios', color: '000000', description: 'iOS specific' },
              { name: 'platform/android', color: '32cd32', description: 'Android specific' },
              
              // Priority labels
              { name: 'priority/high', color: 'ff0000', description: 'High priority' },
              { name: 'priority/medium', color: 'ffa500', description: 'Medium priority' },
              { name: 'priority/low', color: '00ff00', description: 'Low priority' },
              
              // Complexity labels
              { name: 'complexity/high', color: 'ff0000', description: 'High complexity' },
              { name: 'complexity/medium', color: 'ffa500', description: 'Medium complexity' },
              { name: 'complexity/low', color: '00ff00', description: 'Low complexity' },
              
              // Status labels
              { name: 'status/draft', color: '808080', description: 'Draft PR' },
              { name: 'status/ready-for-review', color: '00ff00', description: 'Ready for review' },
              { name: 'automated', color: '9932cc', description: 'Automated PR' }
            ];

            for (const label of labels) {
              try {
                await github.rest.issues.createLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: label.name,
                  color: label.color,
                  description: label.description
                });
                console.log(`Created label: ${label.name}`);
              } catch (error) {
                if (error.status === 422) {
                  // Label already exists, update it
                  await github.rest.issues.updateLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    name: label.name,
                    color: label.color,
                    description: label.description
                  });
                  console.log(`Updated label: ${label.name}`);
                } else {
                  console.error(`Error with label ${label.name}:`, error.message);
                }
              }
            }
